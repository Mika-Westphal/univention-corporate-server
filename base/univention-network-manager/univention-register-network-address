#!/usr/bin/python3
#
# Copyright (C) 2012-2021 Univention GmbH
#
# https://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <https://www.gnu.org/licenses/>.

"""
Save the ip address in LDAP.
"""

import argparse
import sys
from logging import INFO, WARNING, basicConfig, info, warning
from typing import Dict, Set

import netifaces

from univention.config_registry import ucr
from univention.lib.umc import Client, HTTPError, ConnectionError

INTERFACES_IGNORED = {"lo", "docker", "docker0"}


def main() -> int:
	options = parse_args()
	setup_output(options.verbose)
	return process_interfaces(options.interface, options.force)


def parse_args() -> argparse.Namespace:
	parser = argparse.ArgumentParser(description=__doc__)
	parser.add_argument("--interface", "-i", default='all', help="network interface to use")
	parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
	parser.add_argument("--force", "-f", action="store_true", help="register interface even if it is configured static")
	options = parser.parse_args()
	return options


def setup_output(verbose: bool) -> None:
	FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
	basicConfig(format=FORMAT, stream=sys.stderr, level=INFO if verbose else WARNING)


def process_interfaces(iface: str, force: bool) -> int:
	ifaces = get_interfaces(iface) - INTERFACES_IGNORED
	if not ifaces:
		sys.exit('ERROR: no valid interface was given. Try --interface')

	return sum(not(process_one_iface(iface, force)) for iface in ifaces)


def get_interfaces(iface: str) -> Set[str]:
	if iface == "all":
		return set(netifaces.interfaces())
	else:
		return {iface}


def process_one_iface(iface: str, force: bool) -> bool:
	if is_dhcp(iface) or force:
		return try_register_iface(iface)

	info('%s is not configured for DHCP.', iface)
	return True


def is_dhcp(iface: str) -> bool:
	return ucr.get('interfaces/%s/type' % iface) == 'dhcp'


def try_register_iface(iface: str) -> bool:
	try:
		register_iface(iface)
	except (HTTPError, ConnectionError) as exc:
		warning('%s', exc)
		return False
	return True


def register_iface(iface: str) -> None:
	# is fallback different from current address?
	client = Client(ucr['ldap/master'])
	client.authenticate_with_machine_account()
	client.umc_command('ip/change', get_change_data(iface))


def get_change_data(iface: str) -> Dict[str, str]:
	return {
		'ip': ucr.get('interfaces/%s/address' % iface),
		'oldip': ucr.get('interfaces/%s/fallback/address' % iface),
		'netmask': ucr.get('interfaces/%s/netmask' % iface),
		'role': ucr.get('server/role'),
	}


if __name__ == '__main__':
	sys.exit(main())
